import pandas as pd
import numpy as np
from scapy.all import rdpcap, PcapNgReader, IP, TCP, UDP
from collections import defaultdict
from typing import Dict, List, Tuple
import logging
import io

logger = logging.getLogger(__name__)

def analyze_pcap(file) -> List[Dict]:
    try:
        # Check if the file is a BytesIO object (from Streamlit file uploader)
        if isinstance(file, io.BytesIO):
            file.seek(0)  # Reset file pointer to the beginning
            file_content = file.read()
            if file_content.startswith(b'\x0a\x0d\x0d\x0a'):  # PCAPNG magic number
                packets = PcapNgReader(io.BytesIO(file_content))
            else:
                packets = rdpcap(io.BytesIO(file_content))
        else:
            if file.endswith('.pcapng'):
                packets = PcapNgReader(file)
            else:
                packets = rdpcap(file)

        flows = defaultdict(lambda: {'fwd_packets': [], 'bwd_packets': []})

        for packet in packets:
            if IP in packet:
                ip_layer = packet[IP]
                src_ip = ip_layer.src
                dst_ip = ip_layer.dst
                protocol = ip_layer.proto
                timestamp = float(packet.time)

                if TCP in packet:
                    transport_layer = packet[TCP]
                    src_port = transport_layer.sport
                    dst_port = transport_layer.dport
                    flags = int(transport_layer.flags)
                elif UDP in packet:
                    transport_layer = packet[UDP]
                    src_port = transport_layer.sport
                    dst_port = transport_layer.dport
                    flags = 0
                else:
                    continue

                flow_id = f"{src_ip}:{src_port}-{dst_ip}:{dst_port}-{protocol}"
                reverse_flow_id = f"{dst_ip}:{dst_port}-{src_ip}:{src_port}-{protocol}"

                packet_info = {
                    'timestamp': timestamp,
                    'length': len(packet),
                    'flags': flags
                }

                if flow_id in flows:
                    flows[flow_id]['fwd_packets'].append(packet_info)
                elif reverse_flow_id in flows:
                    flows[reverse_flow_id]['bwd_packets'].append(packet_info)
                else:
                    flows[flow_id]['fwd_packets'].append(packet_info)

        logger.info(f"Analyzed {sum(len(flow['fwd_packets']) + len(flow['bwd_packets']) for flow in flows.values())} packets, found {len(flows)} flows")
        return [{'flow_id': k, **v} for k, v in flows.items()]
    except Exception as e:
        logger.error(f"Error analyzing PCAP/PCAPNG file: {str(e)}", exc_info=True)
        raise


def extract_features(flows: List[Dict]) -> pd.DataFrame:
    features = []
    for flow in flows:
        fwd_packets = flow['fwd_packets']
        bwd_packets = flow['bwd_packets']
        all_packets = fwd_packets + bwd_packets

        if not all_packets:
            continue

        flow_duration = max(p['timestamp'] for p in all_packets) - min(p['timestamp'] for p in all_packets)
        
        feature = {
            'Flow ID': flow['flow_id'],
            'Flow Duration': flow_duration,
            'Total Packets': len(all_packets),
            'Packets per Second': len(all_packets) / flow_duration if flow_duration > 0 else 0,
            'Average Packet Size': np.mean([p['length'] for p in all_packets]),
            'Bytes per Second': sum(p['length'] for p in all_packets) / flow_duration if flow_duration > 0 else 0,
            'Proportion of Small Packets': sum(1 for p in all_packets if p['length'] < 60) / len(all_packets),
            'Proportion of Large Packets': sum(1 for p in all_packets if p['length'] > 1000) / len(all_packets),
            'Ratio of Incoming to Outgoing Packets': len(bwd_packets) / len(fwd_packets) if len(fwd_packets) > 0 else 0,
            'Proportion of Packets with Flags': sum(1 for p in all_packets if p['flags'] > 0) / len(all_packets),
        }
        features.append(feature)

    return pd.DataFrame(features)

def detect_trojan_manually(features: pd.DataFrame) -> Tuple[bool, float, List[str]]:
    # Define thresholds for Trojan detection
    PACKETS_PER_SECOND_THRESHOLD = 100
    BYTES_PER_SECOND_THRESHOLD = 50000
    SMALL_PACKET_RATIO_THRESHOLD = 0.7
    LARGE_PACKET_RATIO_THRESHOLD = 0.3
    FLAG_PACKET_RATIO_THRESHOLD = 0.5

    suspicious_flows = 0
    total_flows = len(features)
    reasons = []

    for _, flow in features.iterrows():
        flow_suspicious = False

        if flow['Packets per Second'] > PACKETS_PER_SECOND_THRESHOLD:
            reasons.append(f"High packet rate: {flow['Packets per Second']:.2f} packets/s")
            flow_suspicious = True

        if flow['Bytes per Second'] > BYTES_PER_SECOND_THRESHOLD:
            reasons.append(f"High data rate: {flow['Bytes per Second']:.2f} bytes/s")
            flow_suspicious = True

        if flow['Proportion of Small Packets'] > SMALL_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of small packets: {flow['Proportion of Small Packets']:.2f}")
            flow_suspicious = True

        if flow['Proportion of Large Packets'] > LARGE_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of large packets: {flow['Proportion of Large Packets']:.2f}")
            flow_suspicious = True

        if flow['Proportion of Packets with Flags'] > FLAG_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of packets with flags: {flow['Proportion of Packets with Flags']:.2f}")
            flow_suspicious = True

        if flow_suspicious:
            suspicious_flows += 1

    is_trojan = suspicious_flows / total_flows > 0.5
    confidence = suspicious_flows / total_flows

    return is_trojan, confidence, reasons[:5]  # Return top 5 reasons