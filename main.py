import streamlit as st
import pandas as pd
import numpy as np
import pickle
import joblib
import os
import matplotlib.pyplot as plt
from typing import Tuple, List
import logging
from analyzer import analyze_pcap, extract_features, detect_trojan_manually
from utils import setup_logging, validate_file
from database import init_db, add_detection, get_detection_stats

# Set up logging
logger = setup_logging()

# Initialize database
init_db()

@st.cache_resource
def load_model():
    model_paths = [
        '/home/xueba/Music/AI-Based-Malware-Detector/malware_detector/models/trojan_detector.pkl',
        '/home/xueba/Music/AI-Based-Malware-Detector/malware_detector/models/malcare.joblib'
    ]
    
    for path in model_paths:
        if os.path.exists(path):
            try:
                if path.endswith('.pkl'):
                    with open(path, 'rb') as f:
                        model = pickle.load(f)
                elif path.endswith('.joblib'):
                    model = joblib.load(path)
                logger.info(f"Successfully loaded model from {path}")
                return model
            except Exception as e:
                logger.error(f"Error loading model from {path}: {str(e)}")
    
    logger.warning("No valid model found. Using manual detection method.")
    return None

def detect_malware(features: pd.DataFrame, model) -> Tuple[bool, float, List[str]]:
    if model is not None:
        try:
            X = features.drop(['Flow ID'], axis=1)
            prediction = model.predict(X)[0]
            confidence = model.predict_proba(X)[0].max()
            is_malware = bool(prediction)
            reasons = [f"Model prediction (confidence: {confidence:.2f})"]
            logger.info(f"Made prediction using model: {'Trojan detected' if is_malware else 'Benign'} with confidence {confidence:.2f}")
            return is_malware, confidence, reasons
        except Exception as e:
            logger.error(f"Error making prediction with model: {str(e)}")
            logger.info("Falling back to manual detection method")
    
    # Manual detection
    return detect_trojan_manually(features)

def plot_feature_importance(features: pd.DataFrame):
    fig, ax = plt.subplots(figsize=(10, 6))
    features.mean().sort_values(ascending=False).plot(kind='bar', ax=ax)
    ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
    ax.set_ylabel('Average Value')
    ax.set_title('Feature Importance')
    st.pyplot(fig)

def main():
    st.set_page_config(page_title="Malware Analyzer", page_icon="🛡️", layout="wide")
    st.title("Malware Analyzer")

    model = load_model()



    # Sidebar statistics ( )
    st.sidebar.title("Detection Statistics")
    stats = get_detection_stats()
    st.sidebar.write(f"Total Analyses: {stats['total']}")
    st.sidebar.write(f"Trojans Detected: {stats['malware']}")
    st.sidebar.write(f"Benign Files: {stats['benign']}")

    st.write("Upload a network capture file (PCAP or PCAPNG) to detect potential Trojan malware.")
    
    uploaded_file = st.file_uploader("Choose a network capture file", type=["pcap", "pcapng"])
    
    if st.button("Analyze File"):
        if uploaded_file is not None:
            try:
                validate_file(uploaded_file)

                with st.spinner("Analyzing network capture file..."):
                    flows = analyze_pcap(uploaded_file)
                    if not flows:
                        st.warning("No valid network flows found in the file. Please try a different file.")
                        return
                    features = extract_features(flows)

                with st.spinner("Detecting malware..."):
                    is_malware, confidence, reasons = detect_malware(features, model)

                if is_malware:
                    st.error(f"⚠️ Trojan detected with {confidence:.2f} confidence!")
                    st.write("This file contains network traffic patterns consistent with Trojan malware.")
                else:

                    st.success(f"✅ No Trojan detected. File appears to be benign (confidence: {1-confidence:.2f}).")
                    st.write("A benign file is one that does not contain malicious code or pose a threat to your system.")

                st.subheader("Detection Reasons:")
                for reason in reasons:
                    st.write(f"- {reason}")

                add_detection(is_malware)

                # st.subheader("Feature Importance")
                # plot_feature_importance(features.drop(['Flow ID'], axis=1))

                st.subheader("Next Steps")
                if is_malware:
                    st.write("""
                    1. Isolate the affected device(s) from the network immediately.
                    2. Run a full system scan with up-to-date antivirus software.
                    3. Investigate the source of the infection and potential data breaches.
                    4. Consider professional malware removal services if needed.
                    5. Update all software and strengthen network security measures.
                    """)
                else:
                    st.write("""
                    1. Continue monitoring your network for any unusual activities.
                    2. Regularly update your antivirus and firewall software.
                    3. Conduct periodic network scans to ensure ongoing security.
                    """)

            except Exception as e:
                logger.error(f"An error occurred during analysis: {str(e)}", exc_info=True)
                st.error(f"An error occurred during analysis: {str(e)}. Please try again or contact support if the issue persists.")
        else:
            st.warning("Please upload a network capture file before analyzing.")

    st.sidebar.markdown("[How does it work? Read the docs](https://malwaredocs.com)")


def detect_trojan_manually(features: pd.DataFrame) -> Tuple[bool, float, List[str]]:
    # Define thresholds for Trojan detection
    PACKETS_PER_SECOND_THRESHOLD = 100
    BYTES_PER_SECOND_THRESHOLD = 50000
    SMALL_PACKET_RATIO_THRESHOLD = 0.7
    LARGE_PACKET_RATIO_THRESHOLD = 0.3
    FLAG_PACKET_RATIO_THRESHOLD = 0.5
    INCOMING_OUTGOING_RATIO_THRESHOLD = 2.0

    suspicious_flows = 0
    total_flows = len(features)
    reasons = []

    for _, flow in features.iterrows():
        flow_suspicious = False

        if flow['Packets per Second'] > PACKETS_PER_SECOND_THRESHOLD:
            reasons.append(f"High packet rate: {flow['Packets per Second']:.2f} packets/s (Threshold: {PACKETS_PER_SECOND_THRESHOLD})")
            flow_suspicious = True

        if flow['Bytes per Second'] > BYTES_PER_SECOND_THRESHOLD:
            reasons.append(f"High data rate: {flow['Bytes per Second']:.2f} bytes/s (Threshold: {BYTES_PER_SECOND_THRESHOLD})")
            flow_suspicious = True

        if flow['Proportion of Small Packets'] > SMALL_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of small packets: {flow['Proportion of Small Packets']:.2f} (Threshold: {SMALL_PACKET_RATIO_THRESHOLD})")
            flow_suspicious = True

        if flow['Proportion of Large Packets'] > LARGE_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of large packets: {flow['Proportion of Large Packets']:.2f} (Threshold: {LARGE_PACKET_RATIO_THRESHOLD})")
            flow_suspicious = True

        if flow['Proportion of Packets with Flags'] > FLAG_PACKET_RATIO_THRESHOLD:
            reasons.append(f"High proportion of packets with flags: {flow['Proportion of Packets with Flags']:.2f} (Threshold: {FLAG_PACKET_RATIO_THRESHOLD})")
            flow_suspicious = True

        if flow['Ratio of Incoming to Outgoing Packets'] > INCOMING_OUTGOING_RATIO_THRESHOLD:
            reasons.append(f"High ratio of incoming to outgoing packets: {flow['Ratio of Incoming to Outgoing Packets']:.2f} (Threshold: {INCOMING_OUTGOING_RATIO_THRESHOLD})")
            flow_suspicious = True

        if flow_suspicious:
            suspicious_flows += 1

    is_trojan = suspicious_flows / total_flows > 0.5
    confidence = suspicious_flows / total_flows

    # Summarize reasons
    reason_counts = {}
    for reason in reasons:
        reason_type = reason.split(':')[0]
        reason_counts[reason_type] = reason_counts.get(reason_type, 0) + 1

    summarized_reasons = [
        f"{reason_type}: Found in {count} out of {total_flows} flows"
        for reason_type, count in reason_counts.items()
    ]

    return is_trojan, confidence, summarized_reasons

if __name__ == "__main__":
    main()